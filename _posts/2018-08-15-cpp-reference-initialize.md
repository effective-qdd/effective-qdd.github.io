---
layout: post
title: 初始化
date: 2018-8-15
categories: cpp
tags: reference
excerpt: C++ 语言定义了初始化的好几种形式，这也是初始化问题复杂性的一个体现。作为C++ 11新标准的一部分，用花括号{}来初始化变量得到了全面的应用。
mathjax: true
---

# 初始值

当对象在创建时获得一个特定的值，我们说这个对象被**初始化**了。用于初始化变量的值可以是任意复杂的表达式。

`int i = 0;`
`double d = Foo();`

> 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值代替。

# 初始化

如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式。初始化方式可分为：

* 默认初始化
* 直接初始化
* 拷贝初始化
* 列表初始化

## 默认初始化

如果定义变量时没有指定初始值，则变量被**默认初始化**。此时变量被赋予了**默认值**。
如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将**不被初始化**。一个为被初始化的内置类型变量的值是未定义的。**尽管大多数编译器都能对一部分使用未初始化变量的行为提出警告，但严格来说，编译器并未被要求检查此类错误**。
其他类型各自决定其初始化对象的方式。
绝大多数类都支持无须显示初始化而定义对象，这样的类提供了一个合适的默认值。
`int i; //函数中的定义，编译器会提出警告`
`std::string empty; //empty非显示地初始化为一个空串`

## 直接初始化

不使用等号（=）初始化一个变量，则执行的是直接初始化。

`std::string s("hello");`
`std::vector<int> v(10); //v有10个元素，每个元素都是0`
`std::vector<int> v(10, 1); //v有10个元素，每个元素都是1`

如果初始化要用到的值有多个，一般来说只能使用直接初始化的方式

`std::string s(10, 'a');`

## 拷贝初始化

使用等号（=）初始化一个变量，则执行的是拷贝初始化，编译器把等号右侧的初始化值拷贝到新创建的对象中去。

`std::string s = "hello";`

如果初始化要用到的值有多个，非要用拷贝初始化的方式，则需要显示的创建一个临时对象用于拷贝：

`std::string s = std::string(10, 'a1);`

这个方法和直接初始化相比，可读性较差，也没有任何补偿优势。

## 列表初始化

用一对花括号{}来初始化变量。这种初始化的形式被称为列表初始化。

`int i = {0};`
`std::vector<std::string> v = {"a", "an", "the"};`
`std::vector<int> v{10}; //v有1个元素，该元素都是10`
`std::vector<int> v{10, 1}; //v有2元素，值分别是10和1`

如果我们使用列表初始化且初始值存在丢失的风险，则编译器会报错：

```c++
long double ld = 3.01415926536;
int a{ld}; //错误，转换未执行，因为存在丢失信息的危险
int b(ld); //正确，转换执行，且确实丢失了部分值
```

# 初始化的几种特殊情况

C++ 提供了几种不同的初始化方式，在大多是情况下这些初始化方式可以相互等价使用，不过也并非一直如此，有几种例外的情况：

* 使用拷贝初始化（即使用=）时，只能提供一个初始值。
* 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号初始化。
    ```c++
    class MyClass
    {
        int i = 0;
        int j{ 1 };
    };
    ```
* 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里面进行列表初始化，而不能放在圆括号里面
  * `std::vector<std::string> v("a", "an", "the"); //错误`
